{-# OPTIONS --safe --exact-split --without-K --sized-types #-}

open import C.Lang
open import C.Semantics.SmallStep.Model.State

open import Size
open import Codata.Colist as Colist hiding (_++_ ; [_] ; fromList)
open import Codata.Delay
open import Codata.Thunk
open import Data.Empty
open import Data.Unit hiding (setoid)
open import Data.List hiding (_++_ ; [_])
open import Data.Product
open import Relation.Binary
open import Relation.Binary.PropositionalEquality hiding ([_] ; setoid)
open import Relation.Nullary
open import Relation.Nullary.Decidable
open import Function

import Level
import Data.Integer as โค
import Data.Integer.DivMod as โครท
import Data.Nat as โ
import Data.Bool as ๐น

open Lang โฆ ... โฆ

module C.Semantics.SmallStep.Model.Musical โฆ _ : Lang โฆ where

-- Based on:
-- Coinductive Verification of Program Optimizations Using Similarity Relations by Glesner et al.
-- Undecidability of Equality for Codata Types by Berger and Setzer

data Effect : Set where
  emit : โฆ Int โง โ Effect
  terminated : Effect

data Internal : Set where
  ฯ : Internal
  _โฆ_ : โ { ฮฑ } โ Ref ฮฑ โ โฆ ฮฑ โง โ Internal

infix 10 _โ
infix 10 _โ
data Label : Set where
  _โ : Internal โ Label
  _โ : Effect โ Label

data Reduction (_~[_]โ_ : State โ Label โ State โ Set) : (A : State) โ Size โ Set where
  []   : {i : Size}                                                    โ Reduction _~[_]โ_ ฮฉ i
  _โโท_ : โ { A B ฮฑ i } โ A ~[ ฮฑ โ ]โ B โ        Reduction _~[_]โ_ B  i โ Reduction _~[_]โ_ A i
  _โโท_ : โ { A B ฮฑ i } โ A ~[ ฮฑ โ ]โ B โ Thunk (Reduction _~[_]โ_ B) i โ Reduction _~[_]โ_ A i

Productive : โ { R A i } โ Reduction R A i โ Set
Productive []        = โฅ
Productive (_ โโท xs) = Productive xs
Productive (_ โโท _)  = โค

Effects : Size โ Set
Effects = Colist Effect

data Labels (i : Size) : Set where
  []   :                             Labels i
  _โโท_ : Effect   โ Thunk Labels i โ Labels i
  _โโท_ : Internal โ       Labels i โ Labels i

Next : Label โ (Size โ Set) โ Size โ Set
Next (x โ) C i = C i
Next (x โ) C i = Thunk C i

next : โ { i } (e : Label) โ Labels โ โ Next e Labels i
next (_ โ) = id
next (_ โ) es = ฮป where .force โ es

-- Positivity checker prevents inlining into Labels
_โโท_ : โ { i } (e : Label) โ Next e Labels i โ Labels i
_โโท_ (x โ) = x โโท_
_โโท_ (x โ) = x โโท_

fromList : โ { i } โ List Label โ Labels i
fromList [] = []
fromList (x โ โท xs) = x โโท fromList xs
fromList (x โ โท xs) = x โโท ฮป where .force โ fromList xs

data Finite : Labels โ โ Set where
  []   : Finite []
  _โโท_ : โ x {xs} (fin : Finite (force xs)) โ Finite (x โโท xs)
  _โโท_ : โ x {xs} (fin : Finite xs)         โ Finite (x โโท xs)

_++_ : โ {i} โ Labels โ โ Labels โ โ Labels i
[] ++ ys = ys
(x โโท xs) ++ ys = x โโท ฮป where .force โ force xs ++ ys
(x โโท xs) ++ ys = x โโท (xs ++ ys)

ฯs : โ {i} โ โ.โ โ Labels i
ฯs โ.zero = []
ฯs (โ.suc n) = ฯ โโท ฯs n

labels-of : โ { R A i } โ Reduction R A i โ Labels i
labels-of [] = []
labels-of (_โโท_ {ฮฑ = ฮฑ} _ xs) = ฮฑ โโท labels-of xs
labels-of (_โโท_ {ฮฑ = ฮฑ} _ xs) = ฮฑ โโท ฮป where .force โ labels-of (force xs)

-- bisimilarity
infix 0 [_]_โ_
data [_]_โ_ (i : Size) : Labels โ โ Labels โ โ Set where
  [] : [ i ] [] โ []
  _โโท_ : โ x { xs ys } โ Thunk ([_] force xs โ force ys) i โ [ i ] (x โโท xs) โ (x โโท ys)
  _โโท_ : โ x { xs ys } โ      [ i ]       xs โ ys          โ [ i ] (x โโท xs) โ (x โโท ys)

infix 0 _โ_
_โ_ = [ โ ]_โ_

setoid : โ {โ} โ Set โ โ Setoid _ _
setoid A = record
  { Carrier       = Labels โ
  ; _โ_           = _โ_
  ; isEquivalence = record
    { refl  = โ-refl
    ; sym   = โ-sym
    ; trans = โ-trans
    }
  }
  where
  โ-refl : โ { i } โ Reflexive [ i ]_โ_
  โ-refl {_} {[]}      = []
  โ-refl {_} {x โโท xs} = x โโท ฮป where .force โ โ-refl
  โ-refl {_} {x โโท xs} = x โโท โ-refl

  โ-sym : โ { i } โ Symmetric [ i ]_โ_
  โ-sym []         = []
  โ-sym (x โโท xsโ) = x โโท ฮป where .force โ โ-sym (force xsโ)
  โ-sym (x โโท xsโ) = x โโท โ-sym xsโ

  โ-trans : โ { i } โ Transitive [ i ]_โ_
  โ-trans []         []          = []
  โ-trans (x โโท xsโ) (.x โโท ysโ) = x โโท ฮป where .force โ โ-trans (force xsโ) (force ysโ)
  โ-trans (x โโท xsโ) (.x โโท ysโ) = x โโท โ-trans xsโ ysโ

-- weak bisimilarity
-- see http://www.cse.chalmers.se/~nad/publications/danielsson-up-to-using-sized-types.pdf
infix 0 [_]_[โ]_
data [_]_[โ]_ (i : Size) : Labels โ โ Labels โ โ Set where
  []    :                                                       [ i ] []        [โ] []
  _โท_   : โ x { xs ys } โ Thunk ([_] force xs [โ] force ys) i โ [ i ] (x โโท xs) [โ] (x โโท ys)
  left  : โ x { xs ys } โ      [ i ]       xs [โ] ys          โ [ i ] (x โโท xs) [โ] ys
  right : โ y { xs ys } โ      [ i ]       xs [โ] ys          โ [ i ] xs        [โ] (y โโท ys)
-- NOTE: this representation is not canonical -- left and right are commutative

infix 0 _[โ]_
_[โ]_ = [ โ ]_[โ]_

[โ]-refl : โ {i} โ Reflexive [ i ]_[โ]_
[โ]-refl {_} {[]}       = []
[โ]-refl {_} {_ โโท _}  = _ โท ฮป where .force โ [โ]-refl
[โ]-refl {_} {x โโท xs} = left x (right x [โ]-refl)

[โ]-reflexive : โ { A B i } โ A โ B โ [ i ] A [โ] B
[โ]-reflexive [] = []
[โ]-reflexive (x โโท xsโ) = x โท ฮป where .force โ [โ]-reflexive (force xsโ)
[โ]-reflexive (x โโท xsโ) = left x (right x ([โ]-reflexive xsโ))

[โ]-sym : โ {i} โ Symmetric [ i ]_[โ]_
[โ]-sym [] = []
[โ]-sym (_ โท xs) = _ โท ฮป where .force โ [โ]-sym (force xs)
[โ]-sym (left p x)  = right p ([โ]-sym x)
[โ]-sym (right p x) = left  p ([โ]-sym x)

[โ]-trans : โ { i } โ Trans _[โ]_ _[โ]_ ([ i ]_[โ]_)
[โ]-trans []          []          = []
[โ]-trans []          (right i p) = right i ([โ]-trans [] p)
[โ]-trans (x โท xs)    (.x โท ys)   = _ โท ฮป where .force โ [โ]-trans (force xs) (force ys)
[โ]-trans (x โท xs)    (right i p) = right i ([โ]-trans (x โท xs) p)
[โ]-trans (left i p)  y~z         = left  i ([โ]-trans p y~z)
[โ]-trans (right i p) (right j q) = right j ([โ]-trans (right i p) q)
[โ]-trans (right _ p) (left _ q)  = [โ]-trans p q

[โ]-setoid : Setoid _ _
[โ]-setoid = record
  { Carrier = _
  ; _โ_ = _[โ]_
  ; isEquivalence = record
    { refl = [โ]-refl
    ; sym = [โ]-sym
    ; trans = [โ]-trans
    }
  }

infixr 4 _โโ_
infixr 4 _โโ_
data SmallStep* (_~[_]โ_ : State โ Label โ State โ Set) : State โ State โ Labels โ โ Size โ Set where
  ฮต    : โ { X i }                                                                        โ SmallStep* _~[_]โ_ X X []        i
  _โโ_ : โ { X Y Z e es i } โ X ~[ e โ ]โ Y โ        SmallStep* _~[_]โ_ Y Z es          i โ SmallStep* _~[_]โ_ X Z (e โโท es) i
  _โโ_ : โ { X Y Z e es i } โ X ~[ e โ ]โ Y โ Thunk (SmallStep* _~[_]โ_ Y Z (force es)) i โ SmallStep* _~[_]โ_ X Z (e โโท es) i

-- This is generalized transitivity
_โโ_ : โ { R X Y Z e f i } โ SmallStep* R X Y e โ โ SmallStep* R Y Z f โ โ SmallStep* R X Z (e ++ f) i
ฮต โโ ฮต = ฮต
ฮต โโ (x โโ xs) = x โโ (ฮต โโ xs) -- this is a weird laundering of size
ฮต โโ (x โโ xs) = x โโ xs
(h โโ t) โโ B = h โโ (t โโ B)
(h โโ t) โโ B = h โโ ฮป where .force โ force t โโ B

SmallStepโบ : โ (_~[_]โ_ : State โ Label โ State โ Set) โ State โ State โ Labels โ โ Size โ Set
SmallStepโบ _~[_]โ_ X Y [] _ = โฅ
SmallStepโบ _~[_]โ_ X Y (e โโท es) i = โ[ X' ] (X ~[ e โ ]โ X' ร Thunk (SmallStep* _~[_]โ_ X' Y (force es)) i)
SmallStepโบ _~[_]โ_ X Y (e โโท es) i = โ[ X' ] (X ~[ e โ ]โ X' ร SmallStep* _~[_]โ_ X' Y es i)

record Semantics : Setโ where
  field
    _โข_โ_ : โ { ฮฑ } โ Env โ Expr ฮฑ โ โฆ ฮฑ โง โ Set
    _~[_]โ_ : State โ Label โ State โ Set

    โข-total : โ { ฮฑ E } { e : Expr ฮฑ } โ โ[ v ] (E โข e โ v) -- should ensure no free variables
    โข-det : โ { ฮฑ E } { e : Expr ฮฑ } { v w : โฆ ฮฑ โง } โ E โข e โ v โ E โข e โ w โ v โก w 
    โข-weakening : โ { E E' ฮฑ ฮฒ } { e : Expr ฮฑ } { v : โฆ ฮฑ โง } { x : Ref ฮฒ } { w : โฆ ฮฒ โง }
      โ x โnv E โ x โnv E'
      โ (E โ E') โข e โ v โ (E โ (x Env.โฆ w , ฮต) โ E') โข e โ v
    โข-exchange : โ { E E' ฮฑ ฮณ } { x : Ref ฮฑ } { y : Ref ฮฑ }
      โ { v : โฆ ฮฑ โง } { w : โฆ ฮฑ โง } { e : Expr ฮณ } { ev : โฆ ฮณ โง }
      โ ยฌ (x โก y)
      โ (E โ (x Env.โฆ v , (y Env.โฆ w , ฮต)) โ E') โข e โ ev
      โ (E โ (y Env.โฆ w , (x Env.โฆ v , ฮต)) โ E') โข e โ ev
    -- TODO: variants on Env constructor (and x โกฬธ y and ฮฑ โกฬธ ฮฒ)
    nat : โ { E } n โ E โข โช n โซ โ n
    deref : โ { E ฮฑ } { x : Ref ฮฑ } { v : โฆ ฮฑ โง }
      โ x โฆ v โnv E โ (E โข (โ x) โ v)
    +-eval : โ { E x y x' y' }
      โ E โข x โ x' โ E โข y โ y'
      โ E โข x + y โ (x' โค.+ y')
    *-eval : โ { E x y x' y' }
      โ E โข x โ x' โ E โข y โ y'
      โ E โข x * y โ (x' โค.* y')
    โธ-eval : โ { E x y x' y' }
      โ E โข x โ x' โ E โข y โ y'
      โ E โข x - y โ (x' โค.- y')
    /-eval : โ { E x y x' y' }
      โ E โข x โ x' โ E โข y โ y' โ (y=ฬธ0 : False (โค.โฃ y' โฃ โ.โ 0))
      โ E โข x / y โ ((x' โครท.div y') {y=ฬธ0})
    <-eval : โ { E x y x' y' }
      โ E โข x โ x' โ E โข y โ y'
      โ E โข x < y โ (โ x' โค.<? y' โ)
    >-eval : โ { E x y x' y' }
      โ E โข x โ x' โ E โข y โ y'
      โ E โข x > y โ (โ y' โค.<? x' โ)
    true-eval : โ { E } โ E โข true โ ๐น.true
    false-eval : โ { E } โ E โข false โ ๐น.false
    ||-eval : โ { E x y x' y' }
      โ E โข x โ x' โ E โข y โ y' โ E โข x || y โ (x' ๐น.โจ y')
    &&-eval : โ { E x y x' y' }
      โ E โข x โ x' โ E โข y โ y' โ E โข x && y โ (x' ๐น.โง y')
    โ-eval-t : โ { E c ฮฑ } { x y : Expr ฮฑ } { x' }
      โ E โข c โ ๐น.true โ E โข x โ x' โ E โข c โ x โท y โ x'
    โ-eval-f : โ { E c ฮฑ } { x y : Expr ฮฑ } { y' }
      โ E โข c โ ๐น.false โ E โข y โ y' โ E โข c โ x โท y โ y'

    โ-if-true : โ { E k } { cond : Expr Bool } { sโ sโ : Statement }
      โ E โข cond โ ๐น.true โ ๐ฎ (if cond then sโ else sโ) k E ~[ ฯ โ ]โ ๐ฎ sโ k E
    โ-if-false : โ { E k } { cond : Expr Bool } { sโ sโ : Statement }
      โ E โข cond โ ๐น.false โ ๐ฎ (if cond then sโ else sโ) k E ~[ ฯ โ ]โ ๐ฎ sโ k E
    โ-assignment : โ { E k ฮฑ } { id : Ref ฮฑ } { e : Expr ฮฑ } { v : โฆ ฮฑ โง }
      โ E โข e โ v โ ๐ฎ (id โ e) k E ~[ id โฆ v โ ]โ ๐ฎ nop k (id Env.โฆ v , E)
    โ-seq : โ { E k } { sโ sโ : Statement }
      โ ๐ฎ (sโ ๏ผ sโ) k E ~[ ฯ โ ]โ ๐ฎ sโ (sโ โท k) E
    โ-decl : โ { E k ฮฑ } { f : Ref ฮฑ โ Statement }
      โ โ ฮป (x : Ref ฮฑ) โ (x โnv E) ร (๐ฎ (decl ฮฑ f) k E ~[ ฯ โ ]โ ๐ฎ (f x) k (x , E))
    โ-nop : โ { E k } { s : Statement } โ ๐ฎ nop (s โท k) E ~[ ฯ โ ]โ ๐ฎ s k E
    โ-stuck : โ { E } โ ๐ฎ nop [] E ~[ terminated โ ]โ ฮฉ
    โ-ฮฉ : โ { S' e } โ ยฌ (ฮฉ ~[ e ]โ S')
    โ-for : โ { E k } { l u : Expr Int } { f : Ref Int โ Statement } { x : Ref Int }
      โ ๐ฎ (for l to u then f) k E
        ~[ ฯ โ ]โ ๐ฎ (if (l < u) then (
                (decl Int ฮป i โ i โ l ๏ผ f i) ๏ผ
                for (l + โช โค.+ 1 โซ) to u then f)
             else nop) k E
    โ-while : โ { E k } { e : Expr Bool } { s : Statement }
      โ ๐ฎ (while e then s) k E ~[ ฯ โ ]โ ๐ฎ (if e then (s ๏ผ while e then s) else nop) k E
    โ-putchar : โ { E k } { e : Expr Int } { v : โค.โค }
      โ E โข e โ v โ ๐ฎ (putchar e) k E ~[ emit v โ ]โ ๐ฎ nop k E
    โ-det : โ { S Sโ Sโ e f } โ S ~[ e ]โ Sโ โ S ~[ f ]โ Sโ โ e โก f ร Sโ โก Sโ
    โ-reduce : โ {i} X โ Reduction _~[_]โ_ X i
    โ-irr-cont : โ { s s' kโ kโ E E' e }
      โ ๐ฎ s kโ E ~[ e ]โ ๐ฎ s' kโ E' โ ๐ฎ s kโ E ~[ e ]โ ๐ฎ s' kโ E'

  labels : State โ Labels โ
  labels = labels-of โ โ-reduce

  infix 0 _โโ_
  _โโ_ : Rel State Level.zero
  X โโ Y = labels X [โ] labels Y

  field
    โโ-subst :
      โ { ฮฑ Eโ Eโ k } { v w : โฆ ฮฑ โง } { f : Expr ฮฑ โ Statement } { eโ eโ : Expr ฮฑ }
      โ Eโ โข eโ โ v โ Eโ โข eโ โ w โ v โก w
      โ ๐ฎ (f eโ) k Eโ โโ ๐ฎ (f eโ) k Eโ
    โโ-decl : โ { ฮฑ f k E } โ ๐ฎ (decl ฮฑ ฮป x โ f) k E โโ ๐ฎ f k E
    โโ-cong :
      โ (V : Set) (f : (V โ Statement) โ Statement) (x y : V โ Statement) โ
      (โ v k E โ ๐ฎ (x v) k E โโ ๐ฎ (y v) k E) โ
      (โ k E โ ๐ฎ (f x) k E โโ ๐ฎ (f y) k E)

  Stuck : State โ Set
  Stuck S = โ S' e โ ยฌ (S ~[ e ]โ S')

  data Terminating (X : State) : Set where
    [_] : Stuck X โ Terminating X
    _โท_ : โ { e Y } โ X ~[ e ]โ Y โ Terminating Y โ Terminating X

  _~[_]โ*_ : {i : Size} โ State โ Labels โ โ State โ Set
  _~[_]โ*_ {i} X e Y = SmallStep* _~[_]โ_ X Y e i
  
  _~[_]โโบ_ : {i : Size} โ State โ Labels โ โ State โ Set
  _~[_]โโบ_ {i} X e Y = SmallStepโบ _~[_]โ_ X Y e i
